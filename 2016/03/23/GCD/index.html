<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="GCD," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="GCD 简介CGD 称 Grand Central Dispatch，是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过GCD来管理线程，从而解决线程被创建的问题。
GCD 优势
GCD 能通过推迟昂贵">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD 狂想曲之基本用法">
<meta property="og:url" content="http://yoursite.com/2016/03/23/GCD/index.html">
<meta property="og:site_name" content="一生只做浪漫极客">
<meta property="og:description" content="GCD 简介CGD 称 Grand Central Dispatch，是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过GCD来管理线程，从而解决线程被创建的问题。
GCD 优势
GCD 能通过推迟昂贵">
<meta property="og:image" content="http://yoursite.com/uploads/gcd/thread.jpg">
<meta property="og:image" content="http://yoursite.com/uploads/gcd/serial.png">
<meta property="og:image" content="http://yoursite.com/uploads/gcd/concurrent.png">
<meta property="og:updated_time" content="2016-03-28T08:12:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GCD 狂想曲之基本用法">
<meta name="twitter:description" content="GCD 简介CGD 称 Grand Central Dispatch，是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过GCD来管理线程，从而解决线程被创建的问题。
GCD 优势
GCD 能通过推迟昂贵">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> GCD 狂想曲之基本用法 | 一生只做浪漫极客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一生只做浪漫极客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                GCD 狂想曲之基本用法
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-23T11:11:10+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="GCD-简介"><a href="#GCD-简介" class="headerlink" title="GCD 简介"></a>GCD 简介</h2><p>CGD 称 Grand Central Dispatch，是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。这样通过GCD来管理线程，从而解决线程被创建的问题。</p>
<h2 id="GCD-优势"><a href="#GCD-优势" class="headerlink" title="GCD 优势"></a>GCD 优势</h2><ul>
<li><p>GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。</p>
</li>
<li><p>GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。</p>
</li>
<li><p>GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="GCD-术语"><a href="#GCD-术语" class="headerlink" title="GCD 术语"></a>GCD 术语</h2><ul>
<li>Dispatch Objects </li>
</ul>
<p>尽管GCD是纯C语言的，但它被组建成面向对象的风格。GCD对象被称为dispatch object, 所有的dispatch objects都是OC对象，就如其他OC对象一样，iOS6以上当开启了ARC(automatic reference counting)时,dispatch objects的retain和release都会自动执行。而如果是MRC的话，<code>dispatch objects</code>会使用<code>dispatch_retain</code>和<code>dispatch_release</code>这两个方法来控制引用计数。</p>
<ul>
<li>Serial （串行）&amp; Concurrent（并发）</li>
</ul>
<p>串行任务就是每次只有一个任务被执行，并发任务就是在同一时间可以有多个任务被执行。</p>
<ul>
<li>Synchronous （同步）&amp; Asynchronous（异步）</li>
</ul>
<p>同步函数意思是在完成了它预定的任务后才返回，在任务执行时会阻塞当前线程。而异步函数则是任务会完成但不会等它完成，所以异步函数不会阻塞当前线程，会继续去执行下一个函数。</p>
<ul>
<li>Concurrency （并发）&amp; Parallelism（并行）</li>
</ul>
<p>并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉。并行则是真正意思上的多任务同时运行。如下图所示：</p>
<p><img src="/uploads/gcd/thread.jpg" alt="MacDown logo"></p>
<p>虽然我们可以编写代码在GCD下并发执行，但GCD会决定有多少并行的需求。并行要求并发，但并不能保证并发。</p>
<ul>
<li>Context Switch （上下文切换）</li>
</ul>
<p>一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p>
<ul>
<li>Dispatch Queues 队列</li>
</ul>
<p>GCD 提供有 dispatch queues 来处理代码块，这些队列管理你提供给 GCD 的任务并用 FIFO 顺序执行这些任务。这就保证了第一个被添加到队列里的任务会是队列中第一个开始的任务，而第二个被添加的任务将第二个开始，如此直到队列的终点。Dispatch queues内部使用的是线程，GCD 管理这些线程，并且使用Dispatch queues的时候，我们都不需要自己创建线程。所有的调度队列（dispatch queues）自身都是线程安全的，你能从多个线程并行的访问它们。Dispatch queues相对于和线程直接通信的代码优势是：Dispatch queues使用起来特别方便，执行任务更加有效率。</p>
<ul>
<li>Queue Types</li>
</ul>
<p>GCD有三种队列类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial （串行队列，等待现在执行中处理结束）</td>
<td>将任务以先进先出(FIFO)的顺序来执行，所以串行队列经常用来做访问某些特定资源的同步处理。你可以也根据需要创建多个队列，而这些队列相对其他队列都是并发执行的。换句话说，如果你创建了4个串行队列，每一个队列在同一时间都只执行一个任务，对这四个任务来说，他们是相互独立且并发执行的。如果需要创建串行队列，一般用<code>dispatch_queue_create</code>这个方法来实现。<img src="/uploads/gcd/serial.png" alt="MacDown logo"> （1）这些任务这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。（2）由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区。所以如果访问临界区的唯一方式是通过提交到调度队列的任务，那么你就不需要担心临界区的安全问题了</td>
<td></td>
</tr>
<tr>
<td>Concurrent （并发队列，不等待现在执行中处理结束）</td>
<td>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。这完全取决于 GCD 。在iOS5之前，并发队列一般指的就是全局调度队列(Global Dispatch Queues)，进程中存在四个全局队列：background、low、default 以及 high四个优先级队列，可以调用<code>dispatch_get_global_queue</code>函数传入优先级来访问队列。而在iOS5之后，我们也可以用<code>dispatch_queue_create</code>，并指定队列类型<code>DISPATCH_QUEUE_CONCURRENT</code>，来自己创建一个并发队列。<img src="/uploads/gcd/concurrent.png" alt="MacDown logo">   (1)注意 Block 1,2 和 3 都立马开始运行，一个接一个。在 Block 0 开始后，Block 1等待了好一会儿才开始。同样， Block 3 在 Block 2 之后才开始，但它先于 Block 2 完成。 (2)何时开始一个 Block 完全取决于 GCD 。如果一个 Block 的执行时间与另一个重叠，也是由 GCD 来决定是否将其运行在另一个不同的核心上，如果那个核心可用，否则就用上下文切换的方式来执行不同的 Block 。</td>
<td></td>
</tr>
<tr>
<td>Main dispatch queue（主队列）</td>
<td>与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用<code>dispatch_get_main_queue()</code>来获得。因为main queue是与主线程相关的，所以这是一个串行队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>Critical Section 临界区</li>
</ul>
<p>就是一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（译者注：它的值不再可信）。</p>
<ul>
<li>Race Condition 竞态条件</li>
</ul>
<p>这种状况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，例如程序的并发任务执行的确切顺序。竞态条件可导致无法预测的行为，而不能通过代码检查立即发现。</p>
<ul>
<li>Deadlock 死锁</li>
</ul>
<p>两个（有时更多）东西——在大多数情况下，是线程——所谓的死锁是指它们都卡住了，并等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p>
<ul>
<li>Thread Safe 线程安全</li>
</ul>
<p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃，等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是 NSDictionary 。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary 就不是线程安全的，应该保证一次只能有一个线程访问它。</p>
<h2 id="上手GCD"><a href="#上手GCD" class="headerlink" title="上手GCD"></a>上手GCD</h2><h3 id="我们可以用dispatch-queue-create-const-char-label-dispatch-queue-attr-t-attr-来创建队列"><a href="#我们可以用dispatch-queue-create-const-char-label-dispatch-queue-attr-t-attr-来创建队列" class="headerlink" title="我们可以用dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);来创建队列"></a>我们可以用<code>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);</code>来创建队列</h3><h3 id="串行队列Serial-Dispatch-Queue"><a href="#串行队列Serial-Dispatch-Queue" class="headerlink" title="串行队列Serial Dispatch Queue"></a>串行队列<code>Serial Dispatch Queue</code></h3><p>我们可以用串行队列来替代锁的操作，比如数据资源的同步或修改数据结构时。和锁不同的是，串行队列能保证任务都是在可预见的顺序里执行，而且一旦我们在一个串行队列里异步提交了任务，队列就能永远不发生死锁。不过不像并发队列，这些串行队列是需要我们自己创建和管理的。</p>
<p>我们还可以在程序里创建任意数量的队列，不过值得注意的是，我们要尽量避免为了同时执行队列中的这些任务而去创建大量的串行队列。虽然GCD 通过创建所谓的线程池来大致匹配 CPU 内核数量，但是线程的创建并不是无代价的。每个线程都需要占用内存和内核资源。所以如果需要创建大量的并发任务，我们只需要把这些任务放到并发队列中即可。</p>
<p>如果过多使用多线程，就会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。</p>
<p>只在为了避免多线程编程问题之一——多个线程更新相同资源导致数据竞争时使用 <code>Serial Dispatch Queue</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> mySerialDispatchQueue = dispatch_queue_create(<span class="string">"com.lee.GCD-Demo.MySerialDispatchQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    dispatch_async(mySerialDispatchQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(mySerialDispatchQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(mySerialDispatchQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(mySerialDispatchQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block4"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>当变量queue为Serial Dispatch Queue时，因为要等待现在执行中的处理结束，所以首先执行block1，当block1执行完后，接着执行block2，如此重复。同时执行的处理数只能有一个，所以一定按照block1-&gt; block2 -&gt; block3 -&gt; block4 的顺序执行。</p>
<h3 id="并行队列Concurrent-Dispatch-Queue"><a href="#并行队列Concurrent-Dispatch-Queue" class="headerlink" title="并行队列Concurrent Dispatch Queue"></a>并行队列<code>Concurrent Dispatch Queue</code></h3><p>当想并发执行不发生数据竞争等问题的处理时，使用<code>Concurrent Dispatch Queue</code>。而且对于<code>Concurrent Dispatch Queue</code>来说，不管生成多少，由于XNU内核只使用有效管理的线程，因此不会发生<code>Serial Dispatch Queue</code>的那些问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    创建并行队列</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> myConcurrentQueue = dispatch_queue_create(<span class="string">"com.lee.GCD-Demo.MyConcurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(myConcurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"block4"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>当指定<code>dispatch_queue_attr_t</code>为<code>DISPATCH_QUEUE_CONCURRENT</code>时，即为<code>Concurrent Dispatch Queue</code>。</p>
<p>当变量queue为<code>Concurrent Dispatch Queue</code>时，因为不用等待现在执行中的处理结束，所以首先执行block1，不管block1是否执行完毕，都会接着执行block2，如此重复。所以执行完毕顺序不一定，有可能是按照block1-&gt; block2 -&gt; block4 -&gt; block3 的执行完毕顺序。</p>
<h3 id="主线程队列Main-Dispatch-Queue"><a href="#主线程队列Main-Dispatch-Queue" class="headerlink" title="主线程队列Main Dispatch Queue"></a>主线程队列<code>Main Dispatch Queue</code></h3><p><code>Main Dispatch Queue</code>是在主线程中执行的Dispatch Queue，因为主线程只有一个，所以<code>Main Dispatch Queue</code>自然就是<code>Serial Dispatch Queue</code></p>
<h3 id="全局线程队列Global-Dispatch-Queue"><a href="#全局线程队列Global-Dispatch-Queue" class="headerlink" title="全局线程队列Global Dispatch Queue"></a>全局线程队列<code>Global Dispatch Queue</code></h3><p><code>Global Dispatch Queue</code>是所有应用程序都能够使用的<code>Concurrent Dispatch Queue</code>，没有必要通过<code>dispatch_queue_creat</code> 函数逐个生成<code>Concurrent Dispatch Queue</code>，只要获取<code>Global Dispatch Queue</code>使用即可。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Dispatch Queue</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Main Dispatch Queue</code></td>
<td>Serial Dispatch Queue</td>
<td>主线程执行</td>
</tr>
<tr>
<td><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></td>
<td>执行优先级：高（最高优先级）</td>
</tr>
<tr>
<td><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：默认</td>
</tr>
<tr>
<td><code>DISPATCH_QUEUE_PRIORITY_LOW</code></td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：低</td>
</tr>
<tr>
<td><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code></td>
<td>Concurrent Dispatch Queue</td>
<td>执行优先级：后台</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    获取各种Dispatch Queue</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    Main DisPatch Queue的获取方法</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> mainDispatchQueue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    Global Dispatch Queue的获取方法</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> globalDispatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"-----可并行执行的处理-----"</span>);</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"-------只能在主线程中执行的处理-------"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a><code>dispatch_set_target_queue</code></h3><p><code>dispatch_queue_create</code>函数有两个作用：</p>
<p>（1）用来给新建的queue设置优先级<br><code>dispatch_queue_create</code> 函数生成的Dispatch Queue 不管是 Serial Dispatch Queue 还是Concurrent Dispatch Queue，都使用与默认优先级Global Dispatch Queue 相同执行优先级的线程,要变更生成的Dispatch Queue的执行优先级就要使用<code>dispatch_queue_create</code>函数。</p>
<p>需要注意的是，第一个参数是自定义的queue(默认优先级就是global queue的default)，而不是系统的queue（global/main）。</p>
<p>（2）修改用户队列的目标队列，使多个serial queue在目标queue上一次只有一个执行：</p>
<p>它会把需要执行的任务对象指定到不同的队列中去处理，这个任务对象可以是dispatch队列，也可以是dispatch源。而且这个过程可以是动态的，可以实现队列的动态调度管理等等。比如说有两个队列dispatchA和dispatchB，这时把dispatchA指派到dispatchB：<br>dispatch_set_target_queue(dispatchA, dispatchB);<br>那么dispatchA上还未运行的block会在dispatchB上运行。这时如果暂停dispatchA运行：<br>dispatch_suspend(dispatchA);<br>则只会暂停dispatchA上原来的block的执行，dispatchB的block则不受影响。而如果暂停dispatchB的运行，则会暂停dispatchA的运行。</p>
<p>一般都是把一个任务放到一个串行的queue中，如果这个任务被拆分了，被放置到多个串行的queue中，但实际还是需要这个任务同步执行，那么就会有问题，因为多个串行queue之间是并行的。这时使用dispatch_set_target_queue将多个串行的queue指定到了同一目标，那么着多个串行queue在目标queue上就是同步执行的，不再是并行执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch_set_target_queue的使用</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testTargetQueue&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     (1)用来给新建的queue设置优先级</span><br><span class="line">     </span><br><span class="line">     第一个参数为要设置优先级的queue,第二个参数是参照物，</span><br><span class="line">     既将第一个queue的优先级和第二个queue的优先级设置一样。</span><br><span class="line">     </span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> mySerialQueue = dispatch_queue_create(<span class="string">"com.lee.GCD-Demo.mySerialQueue"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</span><br><span class="line">    dispatch_set_target_queue(mySerialQueue, globalQueue);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     (2)修改用户队列的目标队列，使多个serial queue在目标queue上一次只有一个执行</span><br><span class="line">     </span><br><span class="line">     第一个参数为要设置优先级的queue,第二个参数是参照物，</span><br><span class="line">     既将第一个queue的优先级和第二个queue的优先级设置一样。</span><br><span class="line">     </span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="string">"com.lee.GCD-Demo.mySerialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"com.lee.GCD-Demo.queue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"com.lee.GCD-Demo.queue2"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> queue3 = dispatch_queue_create(<span class="string">"com.lee.GCD-Demo.queue3"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">    dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">    dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">    dispatch_set_target_queue(queue3, targetQueue);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"1 in"</span>);</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">3.0f</span>];</span><br><span class="line">        NSLog(@<span class="string">"1 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue2, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"2 in"</span>);</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">2.0f</span>];</span><br><span class="line">        NSLog(@<span class="string">"2 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue3, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"3 in"</span>);</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">1.0f</span>];</span><br><span class="line">        NSLog(@<span class="string">"3 out"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a><code>dispatch_after</code></h3><p>想在指定时间后执行处理的情况，可以使用<code>dispatch_after</code>函数来实现。要注意的是，并不是在指定时间后执行处理，而只是在指定时间追加处理到Dispatch Queue。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatch_after&#123;</span><br><span class="line">    <span class="comment">//dispatch_after(一定时间后，将执行的操作加入到队列中)</span></span><br><span class="line">    <span class="comment">// &lt;#dispatch_time_t when#&gt; 指定时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.第一种用法</span></span><br><span class="line">    <span class="comment">/* NSEC_PER_SEC 秒</span><br><span class="line">     * NSEC_PER_MSEC 毫秒</span><br><span class="line">     * NSEC_PER_USEC 微秒</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">dispatch_time_t</span> time=dispatch_time(DISPATCH_TIME_NOW, <span class="number">3u</span>ll *NSEC_PER_SEC);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        NSLog(@<span class="string">"after 3s"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.第二种用法</span></span><br><span class="line">    <span class="comment">//&lt;#dispatch_function_t work#&gt; --执行的c语言方法</span></span><br><span class="line">    dispatch_after_f(dispatch_time(DISPATCH_TIME_NOW, <span class="number">3u</span>ll *NSEC_PER_SEC), dispatch_get_main_queue(), <span class="literal">NULL</span>, fun1);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.第三种用法</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">3u</span>ll * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"after 5s"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="preprocessor">#<span class="keyword">warning</span> mark -注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.不是一定时间后执行相应的任务，而是一定时间后，将执行的操作加入到队列中（队列里面再分配执行的时间）</span></span><br><span class="line">    <span class="comment">//2.主线程 RunLoop 1/60秒检测时间，追加的时间范围 3s~(3+1/60)s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"after 3s"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一下代码必先执行完10秒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)demo</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    dispatch_after只是在一定时间后执行处理，而不是开启异步线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建并发队列</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"sc"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="comment">//异步执行</span></span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:<span class="number">10</span>];<span class="comment">//阻塞主线程</span></span><br><span class="line">        NSLog(@<span class="string">"10s --- %@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//延时提交1,队列设置为自定义队列</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">5</span> * NSEC_PER_SEC)), <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">"第1个: 5s --- %@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//延时提交2,队列设置为自定义队列</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">5</span> * NSEC_PER_SEC)), <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">"第2个: 5s --- %@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//延时提交3,队列设置为自定义队列</span></span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(<span class="number">5</span> * NSEC_PER_SEC)), <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">"第3个: 5s --- %@"</span>,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想在dispatch_after 函数中指定具体日期的绝对时间，可以用下面的代码来获取dispatch_time_t</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time_t</span> getDispatchTimeByDate(NSDate *date)&#123;</span><br><span class="line">    NSTimeInterval interval;</span><br><span class="line">    <span class="keyword">double</span> second, subsecond;</span><br><span class="line">    <span class="keyword">struct</span> timespec time;</span><br><span class="line">    <span class="keyword">dispatch_time_t</span> milestone;</span><br><span class="line">    </span><br><span class="line">    interval = [date timeIntervalSince1970];</span><br><span class="line">    subsecond = <span class="built_in">modf</span>(interval, &amp;second);</span><br><span class="line">    time.tv_sec = second;</span><br><span class="line">    time.tv_nsec = subsecond * NSEC_PER_SEC;</span><br><span class="line">    milestone = dispatch_walltime(&amp;time, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> milestone;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a><code>Dispatch Group</code></h3><p>在追加到Dispatch Queue中的多个处理全部结束后想执行处理，这种情况会经常出现。只使用一个Serial Dispath Queue时，只要将想执行的处理全部追加到该Serial Dispath Queue即可实现。但是在使用ConCurrent Dispatch Queue时或同时使用多个Dispath Queue时，源代码就会变得很复杂，此时就适合使用Dispatch Group。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"2"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"3"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@<span class="string">"done"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>因为向Global Dispatch Queue 即 Concurrent Dispatch Queue追加处理，多个线程并行执行，所以追加处理的执行顺序不定。执行时会发生变化。但是执行结果的done一定在最后。</p>
<p>也可以使用dispatch_group_wait函数仅等待全部处理执行结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line">   <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">   dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">       NSLog(@<span class="string">"1"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">       NSLog(@<span class="string">"2"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">       NSLog(@<span class="string">"3"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">   </span><br><span class="line">   NSLog(@<span class="string">"done"</span>);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_wait</code>第二个参数为指定的等待时间<code>dispatch_time_t</code>，指定为<code>DISPATCH_TIME_FOREVER</code>时，意味着永久等待，只要属于Dispatch Group的处理尚未执行结束，就会一直等待，中途不能取消。</p>
<p>如果指定等待间隔为1秒钟时，应做如下的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time_t</span> timeM = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1u</span>ll * NSEC_PER_SEC);</span><br><span class="line">   <span class="keyword">long</span> result = dispatch_group_wait(group, timeM);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//属于 dispatch group的全部处理都执行完毕</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="comment">//属于 dispatch group的某一个处理还在执行中</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_group_wait</code>函数的返回值不为0，就意味着虽然经过了指定的时间，但属于dispatch group的某一个处理还在执行中。如果返回值为0，那么就全部处理执行结束。当等待时间为<code>DISPATCH_TIME_FOREVER</code>，必定全部执行完毕，因此返回值恒为0。</p>
<p>指定<code>DISPATCH_TIME_NOW</code>，则不用任何等待即可判定属于dispatch group的处理是否执行结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> isEnd = dispatch_group_wait(group, DISPATCH_TIME_NOW);</span><br></pre></td></tr></table></figure>
<p>一般情况下， 还是推荐使用<code>dispatch_group_notify</code>，代码更加精简。</p>
<p>可以利用<code>dispatch_group_enter</code>、 <code>dispatch_group_leave</code>和<code>dispatch_group_wait</code>来实现同步</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">MyCoreDataObject *coreDataObject;</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">AFHTTPRequestOperation *operation1 = [[AFHTTPRequestOperation alloc] initWithRequest:request1];</span><br><span class="line">[operation1 setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</span><br><span class="line">    coreDataObject.attribute1 = responseObject;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line">[operation1 start];</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">AFHTTPRequestOperation *operation2 = [[AFHTTPRequestOperation alloc] initWithRequest:request1];</span><br><span class="line">[operation2 setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123;</span><br><span class="line">    coreDataObject.attribute2 = responseObject;</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;];</span><br><span class="line">[operation2 start];</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">[context save:nil];</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a><code>dispatch_barrier_async</code></h3><p> <code>dispatch_barrier_async</code> 和 queue_creat函数生成的Concurrent Dispatch Queue一起使用，<code>dispatch_barrier_async</code> 会等待追加到Concurrent Dispatch Queue上的并行执行的处理全部结束之后，再将指定的处理追加到该Concurrent Dispatch Queue中，然后由<code>dispatch_barrier_async</code> 函数追加的处理执行完毕后，Concurrent Dispatch Queue才恢复为一般的动作，追加到该Concurrent Dispatch Queue的处理又开始并行执行。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"my.concurrent.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">   dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">       NSLog(@<span class="string">"dispatch-1"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">       NSLog(@<span class="string">"dispatch-2"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">       NSLog(@<span class="string">"dispatch-3"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">       NSLog(@<span class="string">"dispatch-4"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">       NSLog(@<span class="string">"dispatch-5"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_barrier_async(concurrentQueue, ^()&#123;</span><br><span class="line">       NSLog(@<span class="string">"dispatch-barrier"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">       NSLog(@<span class="string">"dispatch-6"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">       NSLog(@<span class="string">"dispatch-7"</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   前面<span class="number">5</span>个并行操作都执行完毕之后，再执行`dispatch_barrier_async`，然后并行队列恢复原有执行状态，继续执行后面的并行操作</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a><code>dispatch_sync</code></h3><p>将指定的Block“同步”追加到指定的Dispatch Queue中，再追加Block结束之前，dispatch_sync函数会一直等待。</p>
<p>在dispatch_sync嵌套使用时要注意：不能在一个嵌套中使用同一个serial dispatch queue，因为会发生死锁；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> aSerialDispatchQueue =</span><br><span class="line">    dispatch_queue_create(<span class="string">"com.lee.GCD-Demo.queue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(aSerialDispatchQueue, ^&#123;</span><br><span class="line">        <span class="comment">// block 1</span></span><br><span class="line">        NSLog(@<span class="string">"11111"</span>);</span><br><span class="line">        dispatch_sync(aSerialDispatchQueue, ^&#123;</span><br><span class="line">            <span class="comment">// block 2</span></span><br><span class="line">            NSLog(@<span class="string">"22222"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以发现：<code>22222</code> 这一句永远都无法被打印出来，因为程序产生了死锁。但是为什么会产生死锁呢？</p>
<p>可以想象aSerialDispatchQueue在底层实现中有一把“锁”，这把锁确保serial dispatch queue中只有一个block被执行，当执行到block 1代码时，这把锁为block 1所持有，当block 1执行完了，会释放之；然而block 1同步派发了一个任务block 2，同步派发意味着block 1会被阻塞，直到block 2被执行完成；但是这里产生了矛盾，block 2顺利执行的前提是aSerialDispatchQueue的这把“锁”被block 1释放，但是block 1释放这把“锁”的前提是block 1执行完成，而block 1执行完的前提是block 2执行完成；所以造成的局面是“block 2等待block 1执行完成置放‘锁’”，同时“block 1等待block 2执行完成”，这就是典型的deadlock。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"---"</span>);<span class="comment">//死锁</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">   dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       NSLog(@<span class="string">"1111"</span>); <span class="comment">//死锁</span></span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码也会产生死锁，这类deadlock问题主要针对<code>同步串行队列</code>，对于<code>同步并行队列</code>应该不存在这个问题。「串行队列」在底层实现中应该有一把“锁”用来保证「串行队列」中的block有且仅有一个block被执行；</p>
<h3 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a><code>dispatch_apply</code></h3><p>按指定的次数重复执行block，并等待全部处理执行结束，如需异步返回则嵌套在dispatch_async中来使用。多个block的运行是否并发或串行执行也依赖queue的是否并发或串行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_apply(<span class="number">10</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%zu"</span>, index);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@<span class="string">"done"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.335</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055045</span>] <span class="number">0</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.335</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055100</span>] <span class="number">2</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.335</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055099</span>] <span class="number">1</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.336</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055045</span>] <span class="number">4</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.336</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055045</span>] <span class="number">7</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.335</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055104</span>] <span class="number">3</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.336</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055045</span>] <span class="number">8</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.336</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055100</span>] <span class="number">5</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.336</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055099</span>] <span class="number">6</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.336</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055104</span>] <span class="number">9</span></span><br><span class="line">    <span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">53</span>:<span class="number">25.336</span> GCD_Demo[<span class="number">10391</span>:<span class="number">2055045</span>] done</span><br></pre></td></tr></table></figure>
<p>例如如果要对NSArray类对象的所有元素执行处理时，不必写一个for循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSArray *<span class="built_in">array</span> = @[@<span class="string">"1"</span>, @<span class="string">"2"</span>, @<span class="string">"3"</span>, @<span class="string">"4"</span>, @<span class="string">"5"</span>, @<span class="string">"6"</span>];</span><br><span class="line">    dispatch_apply(<span class="built_in">array</span>.count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, <span class="built_in">array</span>[index]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">35.182</span> GCD_Demo[<span class="number">10593</span>:<span class="number">2057572</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">35.182</span> GCD_Demo[<span class="number">10593</span>:<span class="number">2057619</span>] <span class="number">3</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">35.182</span> GCD_Demo[<span class="number">10593</span>:<span class="number">2057572</span>] <span class="number">5</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">35.182</span> GCD_Demo[<span class="number">10593</span>:<span class="number">2057618</span>] <span class="number">4</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">35.182</span> GCD_Demo[<span class="number">10593</span>:<span class="number">2057620</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">03</span>-<span class="number">24</span> <span class="number">22</span>:<span class="number">57</span>:<span class="number">35.182</span> GCD_Demo[<span class="number">10593</span>:<span class="number">2057619</span>] <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>另外由于dispatch_apply 与dispatch_sync 函数相同，会等待处理执行结束，因此推荐在dispatch_async 函数中非同步地执行 dispatch_apply 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//    在Global Dispatch Queue 中非同步执行</span></span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        Global Dispatch Queue 中等待dispatch_apply函数中全部处理执行结束</span></span><br><span class="line">        </span><br><span class="line">       dispatch_apply([<span class="built_in">array</span> count], <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">           </span><br><span class="line"><span class="comment">//           并列处理所有对象</span></span><br><span class="line">           NSLog(@<span class="string">"%@"</span>, <span class="built_in">array</span>[index]);</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    dispatch_apply 函数中的处理全部执行结束</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    在Main Dispatch Queue中非同步执行</span></span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"><span class="comment">//        用户界面更新等处理</span></span><br><span class="line">        NSLog(@<span class="string">"done"</span>);;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend / dispatch_resume"></a><code>dispatch_suspend</code> / <code>dispatch_resume</code></h3><p><code>dispatch_suspend</code>函数挂起指定的 Dispatch Queue<br> <code>dispatch_resume</code> 函数恢复指定的 Dispatch Queue</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">dispatch_resume(<span class="built_in">queue</span>);</span><br></pre></td></tr></table></figure>
<p>这些函数对于已经执行的处理没有影响，挂起后，追加到Dispatch Queue中但尚未执行的处理在此之后停止执行，而恢复则使得这些处理能够继续执行。</p>
<h3 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a><code>Dispatch Semaphore</code></h3><p>信号量用来管理对资源的并发访问，信号量内部有一个可以原子递增或递减的值。如果一个动作尝试减少信号量的值，使其小于0，那么这个动作将会被阻塞，直到有其他的调用者（在其他线程中）增加该信号量的值。通常一个信号量会被初始化为一个最大值，这个值表示资源可被同时访问的最大数目。该值通常为1，但也可以是更大的值，用来限制并行任务的上限，在生产–消费模式中，信号量一般被初始化为0。</p>
<p>GCD内置了经典的信号量的实现，信号量允许被初始化为任何值，同时支持递增和递减操作。信号量的当前值不能被读取，信号量不依赖调度队列，它可以直接在任何线程中使用。</p>
<p>当我们在处理一系列线程的时候，当数量达到一定量，在以前我们可能会选择使用NSOperationQueue来处理并发控制，但如何在GCD中快速的控制并发呢？答案就是dispatch_semaphore。</p>
<p>信号量是一个整型值并且具有一个初始计数值，并且支持两个操作：信号通知和等待。当一个信号量被信号通知，其计数会被增加。当一个线程在一个信号量上等待时，线程会被阻塞（如果有必要的话），直至计数器大于零，然后线程会减少这个计数。</p>
<p><strong>相关操作函数：</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>dispatch_semaphore_create</code></td>
<td>创建一个semephore</td>
</tr>
<tr>
<td><code>dispatch_semaphore_signal</code></td>
<td>发送一个信号，会让信号总量加1</td>
</tr>
<tr>
<td><code>dispatch_semaphore_wait</code></td>
<td>等待一个信号，当信号总量少于0时，就会一直等待，否则就可以正常执行，并让信号总量-1</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line"><span class="comment">//创建一个信号量</span></span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//        当开启了5个线程，信号量减为0时，就会等待</span></span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">            NSLog(@<span class="string">"%ld"</span>, i);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//            发送信号，信号量加一</span></span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p>以上的代码创建了一个初始值为5的semaphore，每一次循环都会创建一个新的线程，线程结束的时候会发送一个信号，线程创建之前会信号等待，所以当同时创建了5个线程之后，信号量就会变为0，for循环就会阻塞，等待有线程结束之后会增加一个信号才能继续执行，如此一来就形成了对并发数量的控制，以上代码就是一个并发数量为5的线程队列。</p>
<p>在将异步操作转为同步操作时，信号量也是很有用的，此功能在做异步接口的单元测试时尤其有用，例如测试一个有completion block的方法。我们可以在调用此方法后等待该信号量，然后在此方法的comepletion block 中通知该信号量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDownLoad&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@<span class="string">"https://www.baidu.com"</span>];</span><br><span class="line">    </span><br><span class="line">    __block NSURL *myLocation;</span><br><span class="line">    __block NSError *myError;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    [[[NSURLSession sharedSession] downloadTaskWithURL:url completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        myLocation = location;</span><br><span class="line">        myError = error;</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;] resume];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> timeoutInSeconds = <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">dispatch_time_t</span> timeOut = dispatch_time(DISPATCH_TIME_NOW, (<span class="keyword">int64_t</span>)(timeoutInSeconds *NSEC_PER_SEC));</span><br><span class="line">    <span class="keyword">long</span> timeOutResult = dispatch_semaphore_wait(semaphore, timeOut);</span><br><span class="line">    <span class="keyword">if</span> (timeOutResult == <span class="number">0</span>) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, myLocation);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        NSLog(@<span class="string">"%@"</span>, myError);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还有一个多任务下载的例子可以看看编程实战里的例子</p>
<p>信号量属于底层工具，它非常强大，但在大多数需要使用它的场合，最好从设计角度重新考虑，看是否可以不用。应该优先考虑是否可以使用诸如操作队列这样的高级工具。通常可以通过增加一个分派队列配合 <code>dipatch_suspend</code> 或者通过其他方式分解操作来避免使用信号量。信号量并非不好，只是它本身是锁，能不用锁就不要用。但是如果是需要把异步任务转换为同步任务时，信号量是最适合的工具了。</p>
<h3 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a><code>dispatch_once</code></h3><p> <code>dispatch_once</code> 是保证在应用程序执行中只执行一次指定处理。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> pred;</span><br><span class="line">  dispatch_once(&amp;pred, ^&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//初始化的操作</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p> 上面的代码即时在多线程环境下执行，也可以保证百分之百安全。常用于单例模式中，在生成单例的对象时使用。</p>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/GCD/" rel="tag">#GCD</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/09/CocoaPods/" rel="next" title="CocoaPods全解">
                <i class="fa fa-chevron-left"></i> CocoaPods全解
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/28/runtime/" rel="prev" title="Runtime全解">
                Runtime全解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://s8.rr.itc.cn/g/wapChange/201410_19_6/a50sl3914427020305.jpg"
               alt="Small Tiger" />
          <p class="site-author-name" itemprop="name">Small Tiger</p>
          <p class="site-description motion-element" itemprop="description">当你的才华还撑不起你的野心时，你就应该静下心来读读书。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/smalltiger1990" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/lixiaohu_1990" target="_blank">
                  
                    <i class="fa fa-globe"></i> 微博
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/359b31612bed/latest_articles" target="_blank">简书</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-简介"><span class="nav-number">1.</span> <span class="nav-text">GCD 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-优势"><span class="nav-number">2.</span> <span class="nav-text">GCD 优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD-术语"><span class="nav-number">3.</span> <span class="nav-text">GCD 术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上手GCD"><span class="nav-number">4.</span> <span class="nav-text">上手GCD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#我们可以用dispatch-queue-create-const-char-label-dispatch-queue-attr-t-attr-来创建队列"><span class="nav-number">4.1.</span> <span class="nav-text">我们可以用dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);来创建队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串行队列Serial-Dispatch-Queue"><span class="nav-number">4.2.</span> <span class="nav-text">串行队列Serial Dispatch Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行队列Concurrent-Dispatch-Queue"><span class="nav-number">4.3.</span> <span class="nav-text">并行队列Concurrent Dispatch Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主线程队列Main-Dispatch-Queue"><span class="nav-number">4.4.</span> <span class="nav-text">主线程队列Main Dispatch Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局线程队列Global-Dispatch-Queue"><span class="nav-number">4.5.</span> <span class="nav-text">全局线程队列Global Dispatch Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-set-target-queue"><span class="nav-number">4.6.</span> <span class="nav-text">dispatch_set_target_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-after"><span class="nav-number">4.7.</span> <span class="nav-text">dispatch_after</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Group"><span class="nav-number">4.8.</span> <span class="nav-text">Dispatch Group</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-barrier-async"><span class="nav-number">4.9.</span> <span class="nav-text">dispatch_barrier_async</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-sync"><span class="nav-number">4.10.</span> <span class="nav-text">dispatch_sync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-apply"><span class="nav-number">4.11.</span> <span class="nav-text">dispatch_apply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-suspend-dispatch-resume"><span class="nav-number">4.12.</span> <span class="nav-text">dispatch_suspend / dispatch_resume</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Semaphore"><span class="nav-number">4.13.</span> <span class="nav-text">Dispatch Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-once"><span class="nav-number">4.14.</span> <span class="nav-text">dispatch_once</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Small Tiger</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  

  
  


</body>
</html>
