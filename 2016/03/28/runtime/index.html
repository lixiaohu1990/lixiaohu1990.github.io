<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Runtime," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="Runtime介绍Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。
这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime全解">
<meta property="og:url" content="http://yoursite.com/2016/03/28/runtime/index.html">
<meta property="og:site_name" content="一生只做浪漫极客">
<meta property="og:description" content="Runtime介绍Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。
这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它">
<meta property="og:image" content="http://yoursite.com/uploads/runtime/meta_class.png">
<meta property="og:image" content="http://yoursite.com/uploads/runtime/msgsend.png">
<meta property="og:updated_time" content="2016-03-30T03:40:17.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runtime全解">
<meta name="twitter:description" content="Runtime介绍Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。
这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Runtime全解 | 一生只做浪漫极客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一生只做浪漫极客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Runtime全解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-28T15:51:22+08:00" content="2016-03-28">
              2016-03-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/Runtime/" itemprop="url" rel="index">
                    <span itemprop="name">Runtime</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Runtime介绍"><a href="#Runtime介绍" class="headerlink" title="Runtime介绍"></a>Runtime介绍</h2><p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc Runtime。Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p>Objective-C runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。</p>
<a id="more"></a>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="类与对象基础数据结构"><a href="#类与对象基础数据结构" class="headerlink" title="类与对象基础数据结构"></a>类与对象基础数据结构</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>objc/runtime.h中objc_class结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line"></span><br><span class="line">    Class super_class                       OBJC2_UNAVAILABLE;  <span class="comment">// 父类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UNAVAILABLE;  <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UNAVAILABLE;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UNAVAILABLE;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UNAVAILABLE;  <span class="comment">// 该类的实例变量大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  <span class="comment">// 该类的成员变量链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists   OBJC2_UNAVAILABLE;  <span class="comment">// 方法定义的链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                OBJC2_UNAVAILABLE;  <span class="comment">// 方法缓存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  <span class="comment">// 协议链表</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>isa</code> ：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)</li>
<li><code>super_class</code>：指向该类的父类，如果该类已经是最顶层的根类(如<code>NSObject</code>或<code>NSProxy</code>)，则<code>super_class</code>为NULL</li>
<li>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，提高了调用的效率。</li>
<li>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ul>
<p>对于cache，我们用下面的例子来说明其执行过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = [[NSArray alloc] init];</span><br></pre></td></tr></table></figure>
<p>其流程是：</p>
<ul>
<li>[NSArray alloc]先被执行，因为NSArray没有+alloc方法，于是去父类NSObject去查找。</li>
<li>检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。</li>
<li>接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找</li>
<li>在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用</li>
</ul>
<h4 id="objc-object与id"><a href="#objc-object与id" class="headerlink" title="objc_object与id"></a>objc_object与id</h4><p>objc_object是表示一个类的实例的结构体，它的定义如下(objc/objc.h):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *id;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个<code>objc_object</code>数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数<code>class_createInstance</code>来创建<code>objc_object</code>数据结构。</p>
<p>另外还有我们常见的id，它是一个<code>objc_object</code>结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。</p>
<h4 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h4><p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</li>
<li>occupied：一个整数，指定实际占用的缓存bucket的总数。</li>
<li>buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</li>
</ul>
<h4 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h4><p>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = [NSArray array];</span><br></pre></td></tr></table></figure>
<p>这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就有一个问题了，这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">meta-class&#26159;&#19968;&#20010;&#31867;&#23545;&#35937;&#30340;&#31867;</span><br></pre></td></tr></table></figure>
<p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找</p>
<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示：<br><img src="/uploads/runtime/meta_class.png" alt="meta_class"></p>
<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。</p>
<h3 id="类与对象操作函数"><a href="#类与对象操作函数" class="headerlink" title="类与对象操作函数"></a>类与对象操作函数</h3><p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或<code>object_为</code>前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用</p>
<h4 id="类名（name）"><a href="#类名（name）" class="headerlink" title="类名（name）"></a>类名（name）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#33719;&#21462;&#31867;&#30340;&#31867;&#21517;&#10;const char * class_getName ( Class cls );</span><br></pre></td></tr></table></figure>
<p> 如果传入的cls为nil，则返回一个字符串。</p>
<h4 id="父类-super-class-和元类-meta-class"><a href="#父类-super-class-和元类-meta-class" class="headerlink" title="父类(super_class)和元类(meta-class)"></a>父类(<code>super_class</code>)和元类(<code>meta-class</code>)</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> // &#33719;&#21462;&#31867;&#30340;&#29238;&#31867;&#10;Class class_getSuperclass ( Class cls );&#10;&#10;// &#21028;&#26029;&#32473;&#23450;&#30340;Class&#26159;&#21542;&#26159;&#19968;&#20010;&#20803;&#31867;&#10;BOOL class_isMetaClass ( Class cls );</span><br></pre></td></tr></table></figure>
<ul>
<li>class_getSuperclass函数，当cls为Nil或者cls为根类时，返回Nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的</li>
<li>class_isMetaClass函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。</li>
</ul>
<h4 id="实例变量大小（instance-size）"><a href="#实例变量大小（instance-size）" class="headerlink" title="实例变量大小（instance_size）"></a>实例变量大小（<code>instance_size</code>）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#33719;&#21462;&#23454;&#20363;&#22823;&#23567;&#10;size_t class_getInstanceSize ( Class cls );</span><br></pre></td></tr></table></figure>
<h4 id="成员变量-ivars-及属性"><a href="#成员变量-ivars-及属性" class="headerlink" title="成员变量(ivars)及属性"></a>成员变量(ivars)及属性</h4><p>在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#33719;&#21462;&#31867;&#20013;&#25351;&#23450;&#21517;&#31216;&#23454;&#20363;&#25104;&#21592;&#21464;&#37327;&#30340;&#20449;&#24687;&#10;Ivar class_getInstanceVariable ( Class cls, const char *name );&#10;&#10;// &#33719;&#21462;&#31867;&#25104;&#21592;&#21464;&#37327;&#30340;&#20449;&#24687;&#10;Ivar class_getClassVariable ( Class cls, const char *name );&#10;&#10;// &#28155;&#21152;&#25104;&#21592;&#21464;&#37327;&#10;BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );&#10;&#10;// &#33719;&#21462;&#25972;&#20010;&#25104;&#21592;&#21464;&#37327;&#21015;&#34920;&#10;Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>class_getInstanceVariable</code>函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)</li>
<li>class_getClassVariable函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性</li>
<li>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</li>
<li>class_copyIvarList函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。</li>
</ul>
<h4 id="属性操作的函数"><a href="#属性操作的函数" class="headerlink" title="属性操作的函数"></a>属性操作的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#33719;&#21462;&#25351;&#23450;&#30340;&#23646;&#24615;&#10;objc_property_t class_getProperty ( Class cls, const char *name );&#10;&#10;// &#33719;&#21462;&#23646;&#24615;&#21015;&#34920;&#10;objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );&#10;&#10;// &#20026;&#31867;&#28155;&#21152;&#23646;&#24615;&#10;BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );&#10;&#10;// &#26367;&#25442;&#31867;&#30340;&#23646;&#24615;&#10;void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );</span><br></pre></td></tr></table></figure>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const uint8_t * class_getIvarLayout ( Class cls );&#10;&#10;void class_setIvarLayout ( Class cls, const uint8_t *layout );&#10;&#10;const uint8_t * class_getWeakIvarLayout ( Class cls );&#10;&#10;void class_setWeakIvarLayout ( Class cls, const uint8_t *layout );</span><br></pre></td></tr></table></figure>
<p>但通常情况下，我们不需要去主动调用这些方法；在调用objc_registerClassPair时，会生成合理的布局。在此不详细介绍这些函数</p>
<h4 id="方法-methodLists"><a href="#方法-methodLists" class="headerlink" title="方法(methodLists)"></a>方法(methodLists)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#28155;&#21152;&#26041;&#27861;&#10;BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );&#10;&#10;// &#33719;&#21462;&#23454;&#20363;&#26041;&#27861;&#10;Method class_getInstanceMethod ( Class cls, SEL name );&#10;&#10;// &#33719;&#21462;&#31867;&#26041;&#27861;&#10;Method class_getClassMethod ( Class cls, SEL name );&#10;&#10;// &#33719;&#21462;&#25152;&#26377;&#26041;&#27861;&#30340;&#25968;&#32452;&#10;Method * class_copyMethodList ( Class cls, unsigned int *outCount );&#10;&#10;// &#26367;&#20195;&#26041;&#27861;&#30340;&#23454;&#29616;&#10;IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );&#10;&#10;// &#36820;&#22238;&#26041;&#27861;&#30340;&#20855;&#20307;&#23454;&#29616;&#10;IMP class_getMethodImplementation ( Class cls, SEL name );&#10;IMP class_getMethodImplementation_stret ( Class cls, SEL name );&#10;&#10;// &#31867;&#23454;&#20363;&#26159;&#21542;&#21709;&#24212;&#25351;&#23450;&#30340;selector&#10;BOOL class_respondsToSelector ( Class cls, SEL sel );</span><br></pre></td></tr></table></figure>
<ul>
<li>class_addMethod的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用method_setImplementation。一个Objective-C方法是一个简单的C函数，它至少包含两个参数self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethodIMP</span><span class="params">(id self, SEL _cmd)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码。</p>
<ul>
<li>class_getInstanceMethod、class_getClassMethod函数，与class_copyMethodList不同的是，这两个函数都会去搜索父类的实现</li>
<li>class_copyMethodList函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用class_copyMethodList(object_getClass(cls), &amp;count)(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。outCount参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它</li>
<li>class_replaceMethod函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于class_addMethod函数一样会添加方法；如果类中已存在name指定的方法，则类似于method_setImplementation一样替代原方法的实现。</li>
<li>class_getMethodImplementation函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比method_getImplementation(class_getInstanceMethod(cls, name))更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分</li>
<li>class_respondsToSelector函数，我们通常使用NSObject类的respondsToSelector:或instancesRespondToSelector:方法来达到相同目的。</li>
</ul>
<h4 id="协议-objc-protocol-list"><a href="#协议-objc-protocol-list" class="headerlink" title="协议(objc_protocol_list)"></a>协议(objc_protocol_list)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#28155;&#21152;&#21327;&#35758;&#10;BOOL class_addProtocol ( Class cls, Protocol *protocol );&#10;&#10;// &#36820;&#22238;&#31867;&#26159;&#21542;&#23454;&#29616;&#25351;&#23450;&#30340;&#21327;&#35758;&#10;BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );&#10;&#10;// &#36820;&#22238;&#31867;&#23454;&#29616;&#30340;&#21327;&#35758;&#21015;&#34920;&#10;Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );</span><br></pre></td></tr></table></figure>
<ul>
<li>class_conformsToProtocol函数可以使用NSObject类的conformsToProtocol:方法来替代</li>
<li>class_copyProtocolList函数返回的是一个数组，在使用后我们需要使用free()手动释放。</li>
</ul>
<h4 id="版本-version"><a href="#版本-version" class="headerlink" title="版本(version)"></a>版本(version)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#33719;&#21462;&#29256;&#26412;&#21495;&#10;int class_getVersion ( Class cls );&#10;&#10;// &#35774;&#32622;&#29256;&#26412;&#21495;&#10;void class_setVersion ( Class cls, int version );</span><br></pre></td></tr></table></figure>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>runtime还提供了两个函数来供CoreFoundation的tool-free bridging使用，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class objc_getFutureClass ( const char *name );&#10;void objc_setFutureClass ( Class cls, const char *name );</span><br></pre></td></tr></table></figure></p>
<p>通常我们不直接使用这两个函数。</p>
<h3 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h3><p>runtime的强大之处在于它能在运行时创建类和对象</p>
<h4 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21019;&#24314;&#19968;&#20010;&#26032;&#31867;&#21644;&#20803;&#31867;&#10;Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );&#10;&#10;// &#38144;&#27585;&#19968;&#20010;&#31867;&#21450;&#20854;&#30456;&#20851;&#32852;&#30340;&#31867;&#10;void objc_disposeClassPair ( Class cls );&#10;&#10;// &#22312;&#24212;&#29992;&#20013;&#27880;&#20876;&#30001;objc_allocateClassPair&#21019;&#24314;&#30340;&#31867;&#10;void objc_registerClassPair ( Class cls );</span><br></pre></td></tr></table></figure>
<ul>
<li>objc_allocateClassPair函数：如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数</li>
</ul>
<p>为了创建一个新类，我们需要调用objc_allocateClassPair。然后使用诸如class_addMethod，class_addIvar等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用objc_registerClassPair函数来注册类，之后这个新类就可以在程序中使用了。</p>
<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上</p>
<ul>
<li>objc_disposeClassPair函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。</li>
</ul>
<h4 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#21019;&#24314;&#31867;&#23454;&#20363;&#10;id class_createInstance ( Class cls, size_t extraBytes );&#10;&#10;// &#22312;&#25351;&#23450;&#20301;&#32622;&#21019;&#24314;&#31867;&#23454;&#20363;&#10;id objc_constructInstance ( Class cls, void *bytes );&#10;&#10;// &#38144;&#27585;&#31867;&#23454;&#20363;&#10;void * objc_destructInstance ( id obj );</span><br></pre></td></tr></table></figure>
<ul>
<li>class_createInstance函数：创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</li>
</ul>
<p>调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。</p>
<ul>
<li>objc_constructInstance函数：在指定的位置(bytes)创建类实例</li>
<li>objc_destructInstance函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用</li>
</ul>
<h4 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h4><p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<ul>
<li>针对整个对象进行操作的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#36820;&#22238;&#25351;&#23450;&#23545;&#35937;&#30340;&#19968;&#20221;&#25335;&#36125;&#10;id object_copy ( id obj, size_t size );&#10;&#10;// &#37322;&#25918;&#25351;&#23450;&#23545;&#35937;&#21344;&#29992;&#30340;&#20869;&#23384;&#10;id object_dispose ( id obj );</span><br></pre></td></tr></table></figure>
<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，因为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就要以使用以上几个函数来处理这种情况，如下代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSObject *a = [[NSObject alloc] init];</span><br><span class="line">id newB = object_copy(a, class_getInstanceSize(MyClass.<span class="keyword">class</span>));</span><br><span class="line">object_setClass(newB, MyClass.<span class="keyword">class</span>);</span><br><span class="line">object_dispose(a);</span><br></pre></td></tr></table></figure>
<ul>
<li>针对对象实例变量进行操作的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#20462;&#25913;&#31867;&#23454;&#20363;&#30340;&#23454;&#20363;&#21464;&#37327;&#30340;&#20540;&#10;Ivar object_setInstanceVariable ( id obj, const char *name, void *value );&#10;&#10;// &#33719;&#21462;&#23545;&#35937;&#23454;&#20363;&#21464;&#37327;&#30340;&#20540;&#10;Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );&#10;&#10;// &#36820;&#22238;&#25351;&#21521;&#32473;&#23450;&#23545;&#35937;&#20998;&#37197;&#30340;&#20219;&#20309;&#39069;&#22806;&#23383;&#33410;&#30340;&#25351;&#38024;&#10;void * object_getIndexedIvars ( id obj );&#10;&#10;// &#36820;&#22238;&#23545;&#35937;&#20013;&#23454;&#20363;&#21464;&#37327;&#30340;&#20540;&#10;id object_getIvar ( id obj, Ivar ivar );&#10;&#10;// &#35774;&#32622;&#23545;&#35937;&#20013;&#23454;&#20363;&#21464;&#37327;&#30340;&#20540;&#10;void object_setIvar ( id obj, Ivar ivar, id value );</span><br></pre></td></tr></table></figure>
<p>如果实例变量的Ivar已经知道，那么调用object_getIvar会比object_getInstanceVariable函数快，相同情况下，object_setIvar也比object_setInstanceVariable快</p>
<ul>
<li>针对对象的类进行操作的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#36820;&#22238;&#32473;&#23450;&#23545;&#35937;&#30340;&#31867;&#21517;&#10;const char * object_getClassName ( id obj );&#10;&#10;// &#36820;&#22238;&#23545;&#35937;&#30340;&#31867;&#10;Class object_getClass ( id obj );&#10;&#10;// &#35774;&#32622;&#23545;&#35937;&#30340;&#31867;&#10;Class object_setClass ( id obj, Class cls );</span><br></pre></td></tr></table></figure>
<ul>
<li>获取类定义<br>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用objc_addClass函数来注册它们。runtime提供了一系列函数来获取类定义相关的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#33719;&#21462;&#24050;&#27880;&#20876;&#30340;&#31867;&#23450;&#20041;&#30340;&#21015;&#34920;&#10;int objc_getClassList ( Class *buffer, int bufferCount );&#10;&#10;// &#21019;&#24314;&#24182;&#36820;&#22238;&#19968;&#20010;&#25351;&#21521;&#25152;&#26377;&#24050;&#27880;&#20876;&#31867;&#30340;&#25351;&#38024;&#21015;&#34920;&#10;Class * objc_copyClassList ( unsigned int *outCount );&#10;&#10;// &#36820;&#22238;&#25351;&#23450;&#31867;&#30340;&#31867;&#23450;&#20041;&#10;Class objc_lookUpClass ( const char *name );&#10;&#10;Class objc_getClass ( const char *name );&#10;&#10;Class objc_getRequiredClass ( const char *name );&#10;&#10;// &#36820;&#22238;&#25351;&#23450;&#31867;&#30340;&#20803;&#31867;&#10;Class objc_getMetaClass ( const char *name );</span><br></pre></td></tr></table></figure>
<ul>
<li>objc_getClassList函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现</li>
<li>获取类定义的方法有三个：objc_lookUpClass, objc_getClass和objc_getRequiredClass。如果类在运行时未注册，则objc_lookUpClass会返回nil，而objc_getClass会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而objc_getRequiredClass函数的操作与objc_getClass相同，只不过如果没有找到类，则会杀死进程</li>
<li>objc_getMetaClass函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效</li>
</ul>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="类相关操作函数："><a href="#类相关操作函数：" class="headerlink" title="类相关操作函数："></a>类相关操作函数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    Class cls = myClass.<span class="keyword">class</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"class name is %s"</span>, class_getName(cls));</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"MyClass is %@ a meta-class"</span>, class_isMetaClass(cls) ? @<span class="string">""</span> : @<span class="string">"not"</span>);</span><br><span class="line">    </span><br><span class="line">    Class meta_class = objc_getMetaClass(class_getName(cls));</span><br><span class="line">    NSLog(@<span class="string">"%s类对象's meta-class is %s类"</span>, class_getName(cls), class_getName(meta_class));</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"变量实例大小:%zu"</span>, class_getInstanceSize(cls));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//    成员变量，会获取到属性生产的成员变量</span></span><br><span class="line">    Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        NSLog(@<span class="string">"成员变量index: %ld-----name:%s"</span>, i, ivar_getName(ivar));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(ivars);<span class="comment">//一定要记得释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取类中制定名称实例成员变量的信息</span></span><br><span class="line">    Ivar testString = class_getInstanceVariable(cls, <span class="string">"_testString"</span>);</span><br><span class="line">    <span class="keyword">if</span> (testString != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NSLog(@<span class="string">"%s"</span>, ivar_getName(testString));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    属性操作</span></span><br><span class="line">    <span class="keyword">objc_property_t</span> *properties = class_copyPropertyList(cls, &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">        <span class="keyword">objc_property_t</span> property = properties[i];</span><br><span class="line">        NSLog(@<span class="string">"属性 %s"</span>, property_getName(property));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(properties);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    获取指定的属性</span></span><br><span class="line">    <span class="keyword">objc_property_t</span> testArray = class_getProperty(cls, <span class="string">"testArray"</span>);</span><br><span class="line">    <span class="keyword">if</span> (testArray != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NSLog(@<span class="string">"获取指定testArray的属性%s"</span>, property_getName(testArray));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    方法操作  属性的setter getter方法都会在里面</span></span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        NSLog(@<span class="string">"method is %@"</span>, NSStringFromSelector(method_getName(method)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(methods);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    获取指定的方法名</span></span><br><span class="line">    Method method = class_getClassMethod(cls, @selector(classMethod1));</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NSLog(@<span class="string">"获取指定的classMethod1－－－%@"</span>, NSStringFromSelector(method_getName(method)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    IMP imp = class_getMethodImplementation(cls, @selector(method1));</span><br><span class="line">    imp();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    协议</span></span><br><span class="line">    </span><br><span class="line">    Protocol * __unsafe_unretained *protocols = class_copyProtocolList(cls, &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (NSInteger i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        Protocol *protocol = protocols[i];</span><br><span class="line">        NSLog(@<span class="string">"protocol is %s"</span>, protocol_getName(protocol));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"MyClass is %@ responsed to protocol %s"</span>, class_conformsToProtocol(cls, protocols[<span class="number">0</span>]) ? @<span class="string">""</span> : @<span class="string">"not"</span>, protocol_getName(protocols[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
<h4 id="动态创建类和对象-1"><a href="#动态创建类和对象-1" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h4><h2 id="成员变量与属性"><a href="#成员变量与属性" class="headerlink" title="成员变量与属性"></a>成员变量与属性</h2><h3 id="类型编码-Type-Encoding"><a href="#类型编码-Type-Encoding" class="headerlink" title="类型编码(Type Encoding)"></a>类型编码(Type Encoding)</h3><p>在Objective-C Runtime Programming Guide中的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encodings</a>一节中，列出了Objective-C中所有的类型编码。需要注意的是这些类型很多是与我们用于存档和分发的编码类型是相同的。但有一些不能在存档时使用。</p>
<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、retain等等，详情可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="external">Property Type String</a></p>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><ul>
<li>基础数据类型</li>
</ul>
<p>Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_ivar *Ivar;&#10;&#10;struct objc_ivar &#123;&#10;    char *ivar_name                 OBJC2_UNAVAILABLE;  // &#21464;&#37327;&#21517;&#10;    char *ivar_type                 OBJC2_UNAVAILABLE;  // &#21464;&#37327;&#31867;&#22411;&#10;    int ivar_offset                 OBJC2_UNAVAILABLE;  // &#22522;&#22320;&#22336;&#20559;&#31227;&#23383;&#33410;&#10;#ifdef __LP64__&#10;    int space                       OBJC2_UNAVAILABLE;&#10;#endif&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>*<code>objc_property_t</code><br>objc_property_t是表示Objective-C声明的属性的类型，其实际是指向objc_property结构体的指针，其定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_property *objc_property_t;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_property_attribute_t</code></li>
</ul>
<p><code>objc_property_attribute_t</code>定义了属性的特性(attribute)，它是一个结构体，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;&#10;    const char *name;           // &#29305;&#24615;&#21517;&#10;    const char *value;          // &#29305;&#24615;&#20540;&#10;&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<h4 id="关联对象-Associated-Object"><a href="#关联对象-Associated-Object" class="headerlink" title="关联对象(Associated Object)"></a>关联对象(Associated Object)</h4><p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(Ivar)放在类声明的头文件中，或者放在类实现的@implementation后面。但这有一个缺点，我们不能在分类中添加成员变量。如果我们尝试在分类中添加新的成员变量，编译器会报错。</p>
<p>我们可能希望通过使用(甚至是滥用)全局变量来解决这个问题。但这些都不是Ivar，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。</p>
<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(Associated Object)。</p>
<p>我们可以把关联对象想象成一个Objective-C对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个void指针(const void *)。我们还需要指定一个内存管理策略，以告诉Runtime如何管理这个对象的内存。这个内存管理的策略可以由以下值指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSOCIATION_ASSIGN&#10;&#10;OBJC_ASSOCIATION_RETAIN_NONATOMIC&#10;&#10;OBJC_ASSOCIATION_COPY_NONATOMIC&#10;&#10;OBJC_ASSOCIATION_RETAIN&#10;&#10;OBJC_ASSOCIATION_COPY</span><br></pre></td></tr></table></figure>
<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是assign，则宿主释放时，关联对象不会被释放；而如果指定的是retain或者是copy，则宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动retain/copy。当我们需要在多个线程中处理访问关联对象的多线程代码时，这就非常有用了。</p>
<p>我们将一个对象连接到其它对象所需要做的就是下面两行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> myKey;</span><br><span class="line"></span><br><span class="line">objc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure>
<p>在这种情况下，self对象将获取一个新的关联的对象anObject，且内存管理策略是自动retain关联对象，当self对象释放时，会自动release关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id anObject = objc_getAssociatedObject(self, &amp;myKey);</span><br></pre></td></tr></table></figure>
<p>我们可以使用objc_removeAssociatedObjects函数来移除一个关联对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。</p>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#33719;&#21462;&#25104;&#21592;&#21464;&#37327;&#21517;&#10;const char * ivar_getName ( Ivar v );&#10;&#10;// &#33719;&#21462;&#25104;&#21592;&#21464;&#37327;&#31867;&#22411;&#32534;&#30721;&#10;const char * ivar_getTypeEncoding ( Ivar v );&#10;&#10;// &#33719;&#21462;&#25104;&#21592;&#21464;&#37327;&#30340;&#20559;&#31227;&#37327;&#10;ptrdiff_t ivar_getOffset ( Ivar v );</span><br></pre></td></tr></table></figure>
<ul>
<li>ivar_getOffset函数，对于类型id或其它对象类型的实例变量，可以调用object_getIvar和object_setIvar来直接访问成员变量，而不使用偏移量。</li>
</ul>
<h4 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#35774;&#32622;&#20851;&#32852;&#23545;&#35937;&#10;void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );&#10;&#10;// &#33719;&#21462;&#20851;&#32852;&#23545;&#35937;&#10;id objc_getAssociatedObject ( id object, const void *key );&#10;&#10;// &#31227;&#38500;&#20851;&#32852;&#23545;&#35937;&#10;void objc_removeAssociatedObjects ( id object );</span><br></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#33719;&#21462;&#23646;&#24615;&#21517;&#10;const char * property_getName ( objc_property_t property );&#10;&#10;// &#33719;&#21462;&#23646;&#24615;&#29305;&#24615;&#25551;&#36848;&#23383;&#31526;&#20018;&#10;const char * property_getAttributes ( objc_property_t property );&#10;&#10;// &#33719;&#21462;&#23646;&#24615;&#20013;&#25351;&#23450;&#30340;&#29305;&#24615;&#10;char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );&#10;&#10;// &#33719;&#21462;&#23646;&#24615;&#30340;&#29305;&#24615;&#21015;&#34920;&#10;objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>property_copyAttributeValue函数，返回的char *在使用完后需要调用free()释放。</p>
</li>
<li><p>property_copyAttributeList函数，返回值在使用完后需要调用free()释放</p>
</li>
</ul>
<h4 id="实例一："><a href="#实例一：" class="headerlink" title="实例一："></a>实例一：</h4><p>假定这样一个场景，我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们在接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface MyObject : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString    *   name;</span><br><span class="line">@property (nonatomic, copy) NSString    *   status;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setDataWithDic:(NSDictionary *)dic;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>接口A、B返回的字典数据如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@&#123;@<span class="string">"name1"</span>: <span class="string">"张三"</span>, @<span class="string">"status1"</span>: @<span class="string">"start"</span>&#125;</span><br><span class="line"></span><br><span class="line">@&#123;@<span class="string">"name2"</span>: <span class="string">"张三"</span>, @<span class="string">"status2"</span>: @<span class="string">"end"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>通常的方法是写两个方法分别做转换，不过如果能灵活地运用Runtime的话，可以只实现一个转换方法，为此，我们需要先定义一个映射字典(全局变量)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NSMutableDictionary *<span class="built_in">map</span> = nil;</span><br><span class="line"></span><br><span class="line">@implementation MyObject</span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="built_in">map</span> = [NSMutableDictionary dictionary];</span><br><span class="line">    <span class="built_in">map</span>[@<span class="string">"name1"</span>]                = @<span class="string">"name"</span>;</span><br><span class="line">    <span class="built_in">map</span>[@<span class="string">"status1"</span>]              = @<span class="string">"status"</span>;</span><br><span class="line">    <span class="built_in">map</span>[@<span class="string">"name2"</span>]                = @<span class="string">"name"</span>;</span><br><span class="line">    <span class="built_in">map</span>[@<span class="string">"status2"</span>]              = @<span class="string">"status"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将两个字典中不同的字段映射到MyObject中相同的属性上，这样，转换方法可如下处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDataWithDic:(NSDictionary *)dic</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    [dic enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) &#123;</span><br><span class="line">        </span><br><span class="line">        NSString *propertyKey = [self propertyForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (propertyKey)</span><br><span class="line">            </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">objc_property_t</span> property = class_getProperty([self <span class="keyword">class</span>], [propertyKey UTF8String]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 针对特殊数据类型做处理</span></span><br><span class="line">            </span><br><span class="line">            NSString *attributeString = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];</span><br><span class="line">            [self setValue:obj forKey:propertyKey];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)propertyForKey:(NSString *)key&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">map</span> objectForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是要注意的是，一个属性能否通过上面这种方式来处理的前提是其支持KVC</p>
<h4 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h4><p>假定我们想要动态地将一个Tap手势操作连接到任何UIView中，并且根据需要指定点击后的实际操作。这时候我们就可以将一个手势对象及操作的block对象关联到我们的UIView对象中。这项任务分两部分。首先，如果需要，我们要创建一个手势识别对象并将它及block做为关联对象。如下代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    UITapGestureRecognizer *gesture = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!gesture)&#123;</span><br><span class="line">        gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(__handleActionForTapGesture:)];</span><br><span class="line">        </span><br><span class="line">        [self addGestureRecognizer:gesture];</span><br><span class="line">        objc_setAssociatedObject(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    objc_setAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码检测了手势识别的关联对象。如果没有，则创建并建立关联关系。同时，将传入的块对象连接到指定的key上。注意block对象的关联内存管理策略。</p>
<p>手势识别对象需要一个target和action，所以接下来我们定义处理方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture&#123;</span><br><span class="line">    <span class="keyword">if</span> (gesture.state == UIGestureRecognizerStateRecognized)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span>(^action)(<span class="keyword">void</span>) = objc_getAssociatedObject(self, &amp;kDTActionHandlerTapBlockKey);</span><br><span class="line">        <span class="keyword">if</span> (action)&#123;</span><br><span class="line">            action();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要检测手势识别对象的状态，因为我们只需要在点击手势被识别出来时才执行操作。关联对象让我们可以动态地增强类现有的功能。我们可以在实际编码中灵活地运用这一特性。</p>
<h2 id="方法与消息"><a href="#方法与消息" class="headerlink" title="方法与消息"></a>方法与消息</h2><h3 id="基础数据类型-1"><a href="#基础数据类型-1" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL又叫选择器，是表示一个方法的selector的指针，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>objc_selector结构体的详细定义没有在<objc runtime.h="">头文件中找到。方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。</objc></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEL sel1 = @selector(method1);</span><br><span class="line">NSLog(@<span class="string">"sel : %p"</span>, sel1);</span><br><span class="line"></span><br><span class="line">RuntimeTest[<span class="number">52734</span>:<span class="number">466626</span>] sel : <span class="number">0x100002d72</span></span><br></pre></td></tr></table></figure>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的。每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如在某个类中定义以下两个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setWidth:(int)width;&#10;&#10;- (void)setWidth:(double)width;</span><br></pre></td></tr></table></figure>
<p>这样的定义被认为是一种编译错误，所以我们不能像C++, C#那样。而是需要像下面这样来声明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)setWidthIntValue:(int)width;&#10;&#10;-(void)setWidthDoubleValue:(double)width;</span><br></pre></td></tr></table></figure>
<p>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。</p>
<p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。</p>
<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sel_registerName&#20989;&#25968; &#10;&#10;Objective-C&#32534;&#35793;&#22120;&#25552;&#20379;&#30340;@selector()&#10;&#10;NSSelectorFromString()&#26041;&#27861;</span><br></pre></td></tr></table></figure>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。</p>
<p>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<p>通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method用于表示类定义中的方法，则定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;&#10;&#10;struct objc_method &#123;&#10;    SEL method_name                 OBJC2_UNAVAILABLE;  // &#26041;&#27861;&#21517;&#10;    char *method_types                  OBJC2_UNAVAILABLE;&#10;    IMP method_imp                      OBJC2_UNAVAILABLE;  // &#26041;&#27861;&#23454;&#29616;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。具体操作流程我们将在下面讨论。</p>
<h4 id="objc-method-description"><a href="#objc-method-description" class="headerlink" title="objc_method_description"></a><code>objc_method_description</code></h4><p>objc_method_description定义了一个Objective-C方法，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method_description &#123; SEL name; char *types; &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="方法相关操作函数"><a href="#方法相关操作函数" class="headerlink" title="方法相关操作函数"></a>方法相关操作函数</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法操作相关函数包括下以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#35843;&#29992;&#25351;&#23450;&#26041;&#27861;&#30340;&#23454;&#29616;&#10;id method_invoke ( id receiver, Method m, ... );&#10;&#10;// &#35843;&#29992;&#36820;&#22238;&#19968;&#20010;&#25968;&#25454;&#32467;&#26500;&#30340;&#26041;&#27861;&#30340;&#23454;&#29616;&#10;void method_invoke_stret ( id receiver, Method m, ... );&#10;&#10;// &#33719;&#21462;&#26041;&#27861;&#21517;&#10;SEL method_getName ( Method m );&#10;&#10;// &#36820;&#22238;&#26041;&#27861;&#30340;&#23454;&#29616;&#10;IMP method_getImplementation ( Method m );&#10;&#10;// &#33719;&#21462;&#25551;&#36848;&#26041;&#27861;&#21442;&#25968;&#21644;&#36820;&#22238;&#20540;&#31867;&#22411;&#30340;&#23383;&#31526;&#20018;&#10;const char * method_getTypeEncoding ( Method m );&#10;&#10;// &#33719;&#21462;&#26041;&#27861;&#30340;&#36820;&#22238;&#20540;&#31867;&#22411;&#30340;&#23383;&#31526;&#20018;&#10;char * method_copyReturnType ( Method m );&#10;&#10;// &#33719;&#21462;&#26041;&#27861;&#30340;&#25351;&#23450;&#20301;&#32622;&#21442;&#25968;&#30340;&#31867;&#22411;&#23383;&#31526;&#20018;&#10;char * method_copyArgumentType ( Method m, unsigned int index );&#10;&#10;// &#36890;&#36807;&#24341;&#29992;&#36820;&#22238;&#26041;&#27861;&#30340;&#36820;&#22238;&#20540;&#31867;&#22411;&#23383;&#31526;&#20018;&#10;void method_getReturnType ( Method m, char *dst, size_t dst_len );&#10;&#10;// &#36820;&#22238;&#26041;&#27861;&#30340;&#21442;&#25968;&#30340;&#20010;&#25968;&#10;unsigned int method_getNumberOfArguments ( Method m );&#10;&#10;// &#36890;&#36807;&#24341;&#29992;&#36820;&#22238;&#26041;&#27861;&#25351;&#23450;&#20301;&#32622;&#21442;&#25968;&#30340;&#31867;&#22411;&#23383;&#31526;&#20018;&#10;void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );&#10;&#10;// &#36820;&#22238;&#25351;&#23450;&#26041;&#27861;&#30340;&#26041;&#27861;&#25551;&#36848;&#32467;&#26500;&#20307;&#10;struct objc_method_description * method_getDescription ( Method m );&#10;&#10;// &#35774;&#32622;&#26041;&#27861;&#30340;&#23454;&#29616;&#10;IMP method_setImplementation ( Method m, IMP imp );&#10;&#10;// &#20132;&#25442;&#20004;&#20010;&#26041;&#27861;&#30340;&#23454;&#29616;&#10;void method_exchangeImplementations ( Method m1, Method m2 );</span><br></pre></td></tr></table></figure>
<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数receiver不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><p><code>method_getName</code>函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</p>
</li>
<li><p><code>method_getReturnType</code>函数，类型字符串会被拷贝到dst中。</p>
</li>
<li><p><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</p>
</li>
</ul>
<h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#36820;&#22238;&#32473;&#23450;&#36873;&#25321;&#22120;&#25351;&#23450;&#30340;&#26041;&#27861;&#30340;&#21517;&#31216;&#10;const char * sel_getName ( SEL sel );&#10;&#10;// &#22312;Objective-C Runtime&#31995;&#32479;&#20013;&#27880;&#20876;&#19968;&#20010;&#26041;&#27861;&#65292;&#23558;&#26041;&#27861;&#21517;&#26144;&#23556;&#21040;&#19968;&#20010;&#36873;&#25321;&#22120;&#65292;&#24182;&#36820;&#22238;&#36825;&#20010;&#36873;&#25321;&#22120;&#10;SEL sel_registerName ( const char *str );&#10;&#10;// &#22312;Objective-C Runtime&#31995;&#32479;&#20013;&#27880;&#20876;&#19968;&#20010;&#26041;&#27861;&#10;SEL sel_getUid ( const char *str );&#10;&#10;// &#27604;&#36739;&#20004;&#20010;&#36873;&#25321;&#22120;&#10;BOOL sel_isEqual ( SEL lhs, SEL rhs );</span><br></pre></td></tr></table></figure>
<ul>
<li>sel_registerName函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器</li>
</ul>
<h4 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h4><p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即objc_msgSend。这个函数将消息接收者和方法名作为其基础参数，如以下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>
<p>如果消息中还有其它参数，则该方法的形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>这个函数完成了动态绑定的所有事情</p>
<ul>
<li>首先找到selector对应的方法实现，因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ul>
<p>消息的关键在于我们前面章节讨论过的结构体objc_class，这个结构体有两个字段是我们在分发消息的关注的：</p>
<ul>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即methodLists<br>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。<br>下图演示了这样一个消息的基本框架：<br><img src="/uploads/runtime/msgsend.png" alt="meta_class"></li>
</ul>
<p>当消息发送给一个对象时，objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的selector及对应的方法的地址。</p>
<h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p>objc_msgSend有两个隐藏参数</p>
<ul>
<li>消息接收对象</li>
<li>方法的selector<br>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译期被插入实现代码的。</li>
</ul>
<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用_cmd来引用选择器。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>在IMP那节提到过可以避开消息绑定而直接获取方法的地址并调用方法。这种做法很少用，除非是需要持续大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。<br>NSObject类中有个methodForSelector:实例方法，你可以用它来获取某个方法选择器对应的IMP，举个栗子：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> (*setter)(id, SEL, BOOL);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">setter = (<span class="keyword">void</span> (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<p> 当方法被当做函数调用时，上节提到的两个隐藏参数就需要我们明确给出了。上面的例子调用了1000次函数，你可以试试直接给target发送1000次setFilled:消息会花多久。</p>
<p>PS：methodForSelector:方法是由 Cocoa 的 Runtime 系统提供的，而不是 Objc 自身的特性。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform…的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用respondsToSelector:来判断一下。如下代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([self respondsToSelector:@selector(method)]) &#123;</span><br><span class="line">    [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个对象无法接收某一消息时，就会启动所谓”消息转发(message forwarding)“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃。</p>
<p>消息转发机制基本上分为三个步骤:</p>
<ul>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ul>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><p>对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个“处理方法”。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。如下代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionForMethod1</span><span class="params">(id self, SEL _cmd)</span> </span>&#123;</span><br><span class="line">   NSLog(@<span class="string">"%@, %p"</span>, self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:@<span class="string">"method1"</span>]) &#123;</span><br><span class="line">        class_addMethod(self.<span class="keyword">class</span>, @selector(method1), (IMP)functionForMethod1, <span class="string">"@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这种方案更多的是为了实现@dynamic属性</p>
<h5 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h5><p>如果在上一步无法处理消息，则Runtime会继续调以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@interface SUTRuntimeMethodHelper : NSObject</span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line">@end</span><br><span class="line">@implementation SUTRuntimeMethodHelper</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">"%@, %p"</span>, self, _cmd);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> mark -</span></span><br><span class="line"></span><br><span class="line">@<span class="function">interface <span class="title">SUTRuntimeMethod</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    SUTRuntimeMethodHelper *_helper;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SUTRuntimeMethod</span><br><span class="line"></span><br><span class="line">+ (instancetype)object &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [[self alloc] init];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    </span><br><span class="line">    self = [super init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (self != nil) &#123;</span><br><span class="line">        </span><br><span class="line">        _helper = [[SUTRuntimeMethodHelper alloc] init];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    [self performSelector:@selector(method2)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@<span class="string">"forwardingTargetForSelector"</span>);</span><br><span class="line">    NSString *selectorString = NSStringFromSelector(aSelector);</span><br><span class="line"><span class="comment">// 将消息转发给_helper来处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:@<span class="string">"method2"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _helper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [super forwardingTargetForSelector:aSelector];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h5 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h5><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br></pre></td></tr></table></figure>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象。</p>
<p>forwardInvocation:方法的实现有两个任务：</p>
<ul>
<li>定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ul>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重写以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
<p>消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。</p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Runtime/" rel="tag">#Runtime</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/23/GCD/" rel="next" title="GCD 狂想曲之基本用法">
                <i class="fa fa-chevron-left"></i> GCD 狂想曲之基本用法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/31/gcd-deadLock/" rel="prev" title="GCD 狂想曲之线程死锁">
                GCD 狂想曲之线程死锁 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://s8.rr.itc.cn/g/wapChange/201410_19_6/a50sl3914427020305.jpg"
               alt="Small Tiger" />
          <p class="site-author-name" itemprop="name">Small Tiger</p>
          <p class="site-description motion-element" itemprop="description">当你的才华还撑不起你的野心时，你就应该静下心来读读书。</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/smalltiger1990" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/lixiaohu_1990" target="_blank">
                  
                    <i class="fa fa-globe"></i> 微博
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/359b31612bed/latest_articles" target="_blank">简书</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Runtime介绍"><span class="nav-number">1.</span> <span class="nav-text">Runtime介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象"><span class="nav-number">2.</span> <span class="nav-text">类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类与对象基础数据结构"><span class="nav-number">2.1.</span> <span class="nav-text">类与对象基础数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Class"><span class="nav-number">2.1.1.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-object与id"><span class="nav-number">2.1.2.</span> <span class="nav-text">objc_object与id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-cache"><span class="nav-number">2.1.3.</span> <span class="nav-text">objc_cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元类"><span class="nav-number">2.1.4.</span> <span class="nav-text">元类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类与对象操作函数"><span class="nav-number">2.2.</span> <span class="nav-text">类与对象操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类名（name）"><span class="nav-number">2.2.1.</span> <span class="nav-text">类名（name）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#父类-super-class-和元类-meta-class"><span class="nav-number">2.2.2.</span> <span class="nav-text">父类(super_class)和元类(meta-class)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例变量大小（instance-size）"><span class="nav-number">2.2.3.</span> <span class="nav-text">实例变量大小（instance_size）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员变量-ivars-及属性"><span class="nav-number">2.2.4.</span> <span class="nav-text">成员变量(ivars)及属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性操作的函数"><span class="nav-number">2.2.5.</span> <span class="nav-text">属性操作的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收器"><span class="nav-number">2.2.6.</span> <span class="nav-text">垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-methodLists"><span class="nav-number">2.2.7.</span> <span class="nav-text">方法(methodLists)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协议-objc-protocol-list"><span class="nav-number">2.2.8.</span> <span class="nav-text">协议(objc_protocol_list)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本-version"><span class="nav-number">2.2.9.</span> <span class="nav-text">版本(version)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它"><span class="nav-number">2.2.10.</span> <span class="nav-text">其它</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态创建类和对象"><span class="nav-number">2.3.</span> <span class="nav-text">动态创建类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态创建类"><span class="nav-number">2.3.1.</span> <span class="nav-text">动态创建类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态创建对象"><span class="nav-number">2.3.2.</span> <span class="nav-text">动态创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例操作函数"><span class="nav-number">2.3.3.</span> <span class="nav-text">实例操作函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实战"><span class="nav-number">2.4.</span> <span class="nav-text">实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类相关操作函数："><span class="nav-number">2.4.1.</span> <span class="nav-text">类相关操作函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态创建类和对象-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">动态创建类和对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员变量与属性"><span class="nav-number">3.</span> <span class="nav-text">成员变量与属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型编码-Type-Encoding"><span class="nav-number">3.1.</span> <span class="nav-text">类型编码(Type Encoding)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础数据类型"><span class="nav-number">3.1.1.</span> <span class="nav-text">基础数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关联对象-Associated-Object"><span class="nav-number">3.1.2.</span> <span class="nav-text">关联对象(Associated Object)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员变量"><span class="nav-number">3.1.3.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关联对象"><span class="nav-number">3.1.4.</span> <span class="nav-text">关联对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性"><span class="nav-number">3.1.5.</span> <span class="nav-text">属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例一："><span class="nav-number">3.1.6.</span> <span class="nav-text">实例一：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例二"><span class="nav-number">3.1.7.</span> <span class="nav-text">实例二</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法与消息"><span class="nav-number">4.</span> <span class="nav-text">方法与消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础数据类型-1"><span class="nav-number">4.1.</span> <span class="nav-text">基础数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SEL"><span class="nav-number">4.1.1.</span> <span class="nav-text">SEL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IMP"><span class="nav-number">4.1.2.</span> <span class="nav-text">IMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method"><span class="nav-number">4.1.3.</span> <span class="nav-text">Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-method-description"><span class="nav-number">4.1.4.</span> <span class="nav-text">objc_method_description</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法相关操作函数"><span class="nav-number">4.2.</span> <span class="nav-text">方法相关操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">4.2.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法选择器"><span class="nav-number">4.2.2.</span> <span class="nav-text">方法选择器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法调用流程"><span class="nav-number">4.2.3.</span> <span class="nav-text">方法调用流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐藏参数"><span class="nav-number">4.2.4.</span> <span class="nav-text">隐藏参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取方法地址"><span class="nav-number">4.2.5.</span> <span class="nav-text">获取方法地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息转发"><span class="nav-number">4.2.6.</span> <span class="nav-text">消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#动态方法解析"><span class="nav-number">4.2.6.1.</span> <span class="nav-text">动态方法解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#备用接收者"><span class="nav-number">4.2.6.2.</span> <span class="nav-text">备用接收者</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#完整消息转发"><span class="nav-number">4.2.6.3.</span> <span class="nav-text">完整消息转发</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-Swizzling"><span class="nav-number">5.</span> <span class="nav-text">Method Swizzling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议与分类"><span class="nav-number">6.</span> <span class="nav-text">协议与分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拾遗"><span class="nav-number">7.</span> <span class="nav-text">拾遗</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Small Tiger</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  

  
  


</body>
</html>
